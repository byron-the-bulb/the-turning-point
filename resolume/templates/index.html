<!DOCTYPE html>
<html>
<head>
    <title>Turning Point Controller</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background-image: url('../static/TurningPointBackground.png');
            background-size: contain;
            background-position: center;
            background-attachment: fixed;
            background-repeat: no-repeat;
            position: relative;
            min-height: 100vh;
            background-color: #f1ede9; /* Background color around the image */
        }
        body::before {
            content: "";
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: rgba(241, 237, 233, 0.6); /* #f1ede9 with transparency */
            z-index: -1;
        }
        .container {
            display: flex;
            gap: 20px;
        }
        .queue {
            flex: 1;
            background-color: rgba(241, 237, 233, 0.8); /* #f1ede9 with transparency */
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .slots {
            flex: 1;
            background-color: rgba(241, 237, 233, 0.8); /* #f1ede9 with transparency */
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .queue-item {
            padding: 10px;
            border: 1px solid #eee;
            margin-bottom: 10px;
            border-radius: 4px;
            background-color: rgba(248, 248, 248, 0.9);
            cursor: move;
        }
        .slot {
            padding: 20px;
            border: 2px dashed #ccc;
            margin-bottom: 10px;
            border-radius: 4px;
            min-height: 60px;
            background-color: rgba(248, 248, 248, 0.7);
        }
        .slot.dragover {
            background-color: rgba(227, 242, 253, 0.8);
            border-color: #2196F3;
        }
        .queue.dragover {
            background-color: rgba(227, 242, 253, 0.8);
        }
        .slot-item {
            padding: 10px;
            background-color: rgba(76, 175, 80, 0.9);
            color: white;
            border-radius: 4px;
            margin-bottom: 5px;
        }
        h1, h2 {
            text-shadow: 0 0 5px white; /* Add text shadow for better readability */
        }
        .play-all-button {
            background-color: rgba(33, 150, 243, 0.9);
            color: white;
            border: none;
            padding: 15px 30px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 18px;
            margin-top: 20px;
            width: 100%;
            text-shadow: 0 0 5px rgba(0, 0, 0, 0.5); /* Add text shadow for better readability */
            font-weight: bold;
        }
        .play-all-button:hover {
            background-color: rgba(25, 118, 210, 0.95);
        }
        .play-all-button:disabled {
            background-color: rgba(204, 204, 204, 0.8);
            cursor: not-allowed;
        }
        .status {
            margin-top: 10px;
            padding: 10px;
            border-radius: 4px;
        }
        .status.success {
            background-color: #dff0d8;
            color: #3c763d;
        }
        .status.error {
            background-color: #f2dede;
            color: #a94442;
        }
        /* Help notification styles */
        .help-notification {
            position: fixed;
            top: 20px;
            right: 20px;
            padding: 15px 20px;
            border-radius: 8px;
            font-size: 18px;
            font-weight: bold;
            z-index: 1000;
            display: none;
            box-shadow: 0 4px 8px rgba(0,0,0,0.2);
        }
        .help-needed {
            background-color: #f8d7da;
            color: #721c24;
            border: 2px solid #f5c6cb;
            animation: flash 1s infinite alternate;
        }
        @keyframes flash {
            from { opacity: 1; }
            to { opacity: 0.8; }
        }
        .help-controls {
            display: flex;
            justify-content: flex-end;
            gap: 10px;
            margin-top: 10px;
        }
        .help-button {
            background-color: #dc3545;
            color: white;
            border: none;
            padding: 6px 12px;
            border-radius: 4px;
            cursor: pointer;
        }
        .resolve-button {
            background-color: #28a745;
            color: white;
            border: none;
            padding: 6px 12px;
            border-radius: 4px;
            cursor: pointer;
        }
        /* Turning Point playing state */
        .turning-point-playing {
            margin-top: 20px;
            padding: 15px;
            background-color: rgba(255, 193, 7, 0.2);
            border-radius: 8px;
            border: 2px solid rgba(255, 193, 7, 0.5);
            display: none;
        }
        .playing-indicator {
            background-color: rgba(255, 193, 7, 0.9);
            color: #856404;
            font-weight: bold;
            padding: 5px 10px;
            border-radius: 4px;
            animation: pulse 1.5s infinite alternate;
        }
        .timer {
            background-color: rgba(0, 0, 0, 0.1);
            color: #856404;
            font-weight: bold;
            padding: 5px 10px;
            border-radius: 4px;
            margin-left: 10px;
            min-width: 50px;
            display: inline-block;
            text-align: center;
        }
        @keyframes pulse {
            from { background-color: rgba(255, 193, 7, 0.9); }
            to { background-color: rgba(255, 193, 7, 0.6); }
        }
        .slot.disabled, .queue.disabled {
            opacity: 0.7;
            background-color: rgba(241, 237, 233, 0.5);
            cursor: not-allowed;
        }
        .queue-item.disabled {
            cursor: not-allowed;
        }
        .active-video {
            border: 3px solid #ffc107;
            background-color: rgba(255, 248, 225, 0.8);
        }
        .stop-button {
            background-color: rgba(220, 53, 69, 0.9);
            color: white;
            border: none;
            padding: 15px 30px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 18px;
            margin-top: 10px;
            width: 100%;
            text-shadow: 0 0 5px rgba(0, 0, 0, 0.5);
            font-weight: bold;
        }
        .stop-button:hover {
            background-color: rgba(200, 35, 51, 0.95);
        }
        .restart-button {
            background-color: rgba(255, 193, 7, 0.9);
            color: black;
            border: none;
            padding: 15px 30px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 18px;
            margin-top: 10px;
            width: 100%;
            text-shadow: 0 0 2px rgba(255, 255, 255, 0.5);
            font-weight: bold;
        }
        .restart-button:hover {
            background-color: rgba(240, 173, 0, 0.95);
        }
        .fill-button {
            background-color: rgba(13, 110, 253, 0.9);
            color: white;
            border: none;
            padding: 15px 30px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 18px;
            margin-top: 10px;
            width: 100%;
            text-shadow: 0 0 5px rgba(0, 0, 0, 0.5);
            font-weight: bold;
        }
        .fill-button:hover {
            background-color: rgba(10, 88, 202, 0.95);
        }
        .fill-button:disabled {
            background-color: rgba(13, 110, 253, 0.5);
            cursor: not-allowed;
        }
        .button-container {
            display: flex;
            flex-direction: column;
            gap: 10px;
            margin-top: 20px;
        }
        .discard-bucket {
            background-color: rgba(108, 117, 125, 0.8);
            border: 2px dashed #dc3545;
            color: white;
            padding: 15px;
            margin-top: 20px;
            border-radius: 8px;
            text-align: center;
            min-height: 80px;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            transition: all 0.3s;
        }
        .discard-bucket.dragover {
            background-color: rgba(220, 53, 69, 0.8);
            border-style: solid;
        }
        .discard-bucket i {
            font-size: 24px;
            margin-bottom: 10px;
        }
    </style>
</head>
<body>
    <h1>Turning Point Controller</h1>
    
    <!-- Help notification panel -->
    <div id="helpNotification" class="help-notification help-needed">
        <span id="helpMessage"></span>
        <div class="help-controls">
            <button id="resolveHelpButton" class="resolve-button">Resolve</button>
        </div>
    </div>
    
    <div class="help-controls" style="margin-bottom: 20px;">
        <button id="testHelpButton" class="help-button">Test Help Request</button>
    </div>

    <!-- Turning Point Playing Status -->
    <div id="turningPointPlaying" class="turning-point-playing">
        <h3>Turning Point Running</h3>
        <div>
            <span class="playing-indicator">NOW PLAYING</span>
            <span id="currentVideoPlaying">Intro Video</span>
            <span class="timer" id="videoTimer">0:00</span>
        </div>
        <p>Please wait until all videos finish playing before making changes.</p>
    </div>

    <div class="container">
        <div class="queue" id="queue">
            <h2>Waiting Burners</h2>
            
            <!-- Add the fill button above the queue -->
            <button id="fill-button" class="fill-button" onclick="fillSlotsFromQueue()">
                Fill Slots from Queue
            </button>
            
            <div id="queue-list">
                <!-- Queue items will be added here dynamically -->
            </div>
            
            <!-- Discard bucket -->
            <div class="discard-bucket" id="discard-bucket">
                <i>🗑️</i>
                <div>Burner got too high or disappeared</div>
                <small>(Drag and drop here to remove)</small>
            </div>
        </div>

        <div class="slots">
            <h2>Slots on the Turning Point</h2>
            <div id="slots-container">
                <!-- 6 slots will be added here -->
            </div>
            <div class="button-container">
            <button id="play-all-button" class="play-all-button" onclick="playAllVideos()" disabled>
                    START Turning Point
                </button>
                <button id="stop-button" class="stop-button" onclick="stopAllVideos()">
                    STOP Turning Point (and clear burners)
                </button>
                <button id="restart-button" class="restart-button" onclick="restartTurningPoint()">
                    STOP (and keep burners)
            </button>
            </div>
        </div>
    </div>

    <div id="status" class="status" style="display: none;"></div>

    <script>
        // Turning Point state
        let isTurningPointRunning = false;
        let currentPlayingVideo = ""; // Track which video is currently playing
        let activeVideoIndex = -1; // Track which slot is active
        
        // Initialize slots
        const slotsContainer = document.getElementById('slots-container');
        for (let i = 0; i < 6; i++) {
            const slot = document.createElement('div');
            slot.className = 'slot';
            slot.id = `slot-${i}`;
            slot.ondragover = (e) => {
                // Check if this specific slot is disabled
                if (slot.classList.contains('disabled')) {
                    e.preventDefault();
                    return; // Don't allow drop on disabled slots
                }
                e.preventDefault();
                slot.classList.add('dragover');
            };
            slot.ondragleave = () => {
                slot.classList.remove('dragover');
            };
            slot.ondrop = (e) => {
                // Check if this specific slot is disabled
                if (slot.classList.contains('disabled')) {
                    e.preventDefault();
                    return; // Don't allow drop on disabled slots
                }
                e.preventDefault();
                slot.classList.remove('dragover');
                const itemId = e.dataTransfer.getData('text/plain');
                const item = document.getElementById(itemId);
                if (item) {
                    // Remove item from its current location
                    item.parentNode.removeChild(item);
                    // Add to new slot
                    slot.appendChild(item);
                    updatePlayAllButton();
                }
            };
            slotsContainer.appendChild(slot);
        }

        // Help notification functionality
        const helpNotification = document.getElementById('helpNotification');
        const helpMessage = document.getElementById('helpMessage');
        const testHelpButton = document.getElementById('testHelpButton');
        const resolveHelpButton = document.getElementById('resolveHelpButton');
        
        // Current help state
        let currentHelpState = {
            help_needed: false,
            help_user: ''
        };
        
        // Update the help notification UI
        function updateHelpUI(helpState) {
            currentHelpState = helpState;
            
            if (helpState.help_needed) {
                helpMessage.textContent = `${helpState.help_user} NEEDS HELP`;
                helpNotification.style.display = 'block';
            } else {
                helpNotification.style.display = 'none';
            }
        }
        
        // Fetch help status
        async function fetchHelpStatus() {
            try {
                const response = await fetch('/help_status');
                const data = await response.json();
                updateHelpUI(data);
            } catch (error) {
                console.error('Error fetching help status:', error);
            }
        }
        
        // Send help request
        async function sendHelpRequest(user, needsHelp) {
            try {
                const response = await fetch('/needs_help', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        user: user,
                        needs_help: needsHelp
                    })
                });
                
                const data = await response.json();
                updateHelpUI(data);
                
                // Update status message
                const status = document.getElementById('status');
                status.style.display = 'block';
                
                if (needsHelp) {
                    status.className = 'status error';
                    status.textContent = `Help requested for: ${user}`;
                } else {
                    status.className = 'status success';
                    status.textContent = `Help resolved for: ${user}`;
                }
                
                setTimeout(() => {
                    status.style.display = 'none';
                }, 3000);
                
                return data;
            } catch (error) {
                console.error('Error sending help request:', error);
                // Show error in status
                const status = document.getElementById('status');
                status.style.display = 'block';
                status.className = 'status error';
                status.textContent = `Error: ${error.message}`;
                setTimeout(() => {
                    status.style.display = 'none';
                }, 3000);
            }
        }
        
        // Event listeners for help buttons
        testHelpButton.addEventListener('click', () => {
            const user = prompt('Enter user or stage name:') || 'Test User';
            sendHelpRequest(user, true);
        });
        
        resolveHelpButton.addEventListener('click', () => {
            if (currentHelpState.help_needed) {
                sendHelpRequest(currentHelpState.help_user, false);
            }
        });

        function findFirstEmptySlot() {
            const slots = document.querySelectorAll('.slot');
            for (let i = 0; i < slots.length; i++) {
                if (slots[i].children.length === 0 && !slots[i].classList.contains('disabled')) {
                    return slots[i];
                }
            }
            return null;
        }

        function updateQueue() {
            // Always update the queue, even when turning point is running
            fetch('/queue')
                .then(response => response.json())
                .then(data => {
                    const queueList = document.getElementById('queue-list');
                    const existingItems = new Set();
                    
                    // Track existing burners by their unique combination of attributes rather than by id
                    const existingBurnerKeys = new Set();
                    document.querySelectorAll('.queue-item').forEach(item => {
                        if (item.dataset.name && item.dataset.challenge_point && item.dataset.envi_state) {
                            // Create a unique key for each burner based on their data
                            const key = `${item.dataset.name}|${item.dataset.challenge_point}|${item.dataset.envi_state}`;
                            existingBurnerKeys.add(key);
                        }
                        existingItems.add(item.id);
                    });
                    
                    // Check if queue is empty before we add new items
                    // This is needed to determine if we should auto-fill slots
                    const queueIsEmpty = queueList.children.length === 0;
                    
                    // Add any new items that aren't already displayed
                    data.forEach((item, index) => {
                        // Create a unique identifier for this burner
                        const burnerKey = `${item.name}|${item.challenge_point}|${item.envi_state}`;
                        
                        // Only add if this unique burner is not already displayed somewhere
                        if (!existingBurnerKeys.has(burnerKey)) {
                            // Create a stable ID that doesn't change when queue order changes
                            const itemId = `queue-item-${burnerKey.replace(/[^a-zA-Z0-9]/g, '-')}`;
                            
                            const div = document.createElement('div');
                            div.className = 'queue-item';
                            div.id = itemId;
                            div.draggable = true;
                            div.ondragstart = (e) => {
                                // Check if this specific item is disabled
                                if (div.classList.contains('disabled')) {
                                    e.preventDefault();
                                    return; // Don't allow drag of disabled items
                                }
                                e.dataTransfer.setData('text/plain', div.id);
                            };
                            // Store all the identifying information
                            div.dataset.video = item.video;
                            div.dataset.channel = item.channel;
                            div.dataset.name = item.name;
                            div.dataset.challenge_point = item.challenge_point;
                            div.dataset.envi_state = item.envi_state;
                            div.innerHTML = `
                                <strong>${item.name}</strong> - ${item.challenge_point} to ${item.envi_state}
                            `;
                            
                            // Only auto-fill slots if:
                            // 1. Turning point is not running
                            // 2. Queue was empty before adding this new item (meaning this is a fresh arrival)
                            // 3. There are empty slots available
                            if (!isTurningPointRunning && queueIsEmpty) {
                                // Try to place in first empty slot that's not disabled
                                const emptySlot = findFirstEmptySlot();
                                if (emptySlot && !emptySlot.classList.contains('disabled')) {
                                    emptySlot.appendChild(div);
                                } else {
                                    queueList.appendChild(div);
                                }
                            } else {
                                // Always add to queue otherwise
                                queueList.appendChild(div);
                            }
                        }
                    });
                    updatePlayAllButton();
                });
        }

        // Make queue a drop target
        const queue = document.getElementById('queue');
        queue.ondragover = (e) => {
            e.preventDefault();
            queue.classList.add('dragover');
        };
        queue.ondragleave = () => {
            queue.classList.remove('dragover');
        };
        queue.ondrop = (e) => {
            e.preventDefault();
            queue.classList.remove('dragover');
            const itemId = e.dataTransfer.getData('text/plain');
            const item = document.getElementById(itemId);
            if (item) {
                // Remove item from its current location
                item.parentNode.removeChild(item);
                // Add to queue
                document.getElementById('queue-list').appendChild(item);
                updatePlayAllButton();
            }
        };

        function updatePlayAllButton() {
            const playAllButton = document.getElementById('play-all-button');
            const slots = document.querySelectorAll('.slot');
            const hasItems = Array.from(slots).some(slot => slot.children.length > 0);
            playAllButton.disabled = !hasItems || isTurningPointRunning;
        }

        function setTurningPointState(isRunning, currentVideo = "Intro Video") {
            console.log(`Setting turning point state: running=${isRunning}, video=${currentVideo}`);
            isTurningPointRunning = isRunning;
            currentPlayingVideo = currentVideo;
            
            // Update UI elements
            const playingDiv = document.getElementById('turningPointPlaying');
            const currentVideoText = document.getElementById('currentVideoPlaying');
            const playAllButton = document.getElementById('play-all-button');
            const fillButton = document.getElementById('fill-button');
            
            if (isRunning) {
                // Show playing indicator
                playingDiv.style.display = 'block';
                currentVideoText.textContent = currentVideo;
                
                // Only disable play button, keep fill button enabled
                playAllButton.disabled = true;
                
                // Only disable the slots, don't disable the queue
                document.querySelectorAll('.slot').forEach(slot => {
                    slot.classList.add('disabled');
                });
            } else {
                // Hide playing indicator
                playingDiv.style.display = 'none';
                
                // Enable buttons
                updatePlayAllButton();
                
                // Clear any timer interval
                if (window.countdownInterval) {
                    clearInterval(window.countdownInterval);
                    window.countdownInterval = null;
                }
                
                // If this is a natural completion of the experience (not manual restart),
                // clear all slots when the state changes to not running
                if (currentVideo === "Finishing in groups (30 seconds)") {
                    console.log("Natural completion of the experience - clearing slots");
                    
                    // Get full data for all burners in slots before clearing them
                    const burnersToRemove = [];
                    document.querySelectorAll('.slot .queue-item').forEach(item => {
                        if (item.dataset.name) {
                            // Extract all necessary identifying information
                            const burnerData = {
                                name: item.dataset.name,
                                challenge_point: item.dataset.challenge_point,
                                envi_state: item.dataset.envi_state
                            };
                            burnersToRemove.push(burnerData);
                        }
                    });
                    
                    console.log('Burners to remove from backend queue:', burnersToRemove);
                    
                    // Clear slots
                    document.querySelectorAll('.slot').forEach(slot => {
                        slot.innerHTML = '';
                    });
                    
                    // Remove specific burners from backend queue
                    if (burnersToRemove.length > 0) {
                        removeFromBackendQueue(burnersToRemove);
                    }
                }
                
                // Remove all disabled classes
                document.querySelectorAll('.slot').forEach(slot => {
                    slot.classList.remove('disabled');
                });
                document.querySelectorAll('.queue-item').forEach(item => {
                    item.classList.remove('disabled');
                    item.draggable = true;
                });
            }
        }

        function startCountdownTimer(seconds, onComplete = null) {
            console.log(`Starting countdown: ${seconds} seconds`);
            // Clear any existing timer interval
            if (window.countdownInterval) {
                clearInterval(window.countdownInterval);
            }
            
            const timerElement = document.getElementById('videoTimer');
            let remainingSeconds = seconds;
            
            // Update timer immediately
            updateTimerDisplay(remainingSeconds, timerElement);
            
            // Then update every second
            window.countdownInterval = setInterval(() => {
                remainingSeconds--;
                
                updateTimerDisplay(remainingSeconds, timerElement);
                
                if (remainingSeconds <= 0) {
                    clearInterval(window.countdownInterval);
                    window.countdownInterval = null;
                    console.log('Timer completed');
                    if (onComplete && typeof onComplete === 'function') {
                        console.log('Executing onComplete callback');
                        onComplete();
                    }
                }
            }, 1000);
        }
        
        function updateTimerDisplay(seconds, element) {
            const minutes = Math.floor(seconds / 60);
            const remainingSeconds = seconds % 60;
            element.textContent = `${minutes}:${remainingSeconds.toString().padStart(2, '0')}`;
        }

        function updateActiveVideo(slotIndex) {
            console.log(`Updating active video to slot ${slotIndex}`);
            activeVideoIndex = slotIndex;
            
            // Clear previous active video and disabled status
            document.querySelectorAll('.slot').forEach(slot => {
                slot.classList.remove('active-video');
            });
            
            // Set new active video if index is valid
            if (slotIndex >= 0) {
                const activeSlot = document.getElementById(`slot-${slotIndex}`);
                if (activeSlot) {
                    // Add active-video class and disabled class
                    activeSlot.classList.add('active-video');
                    activeSlot.classList.add('disabled');
                    
                    // Disable dragging for the item in this slot
                    const queueItem = activeSlot.querySelector('.queue-item');
                    if (queueItem) {
                        queueItem.classList.add('disabled');
                        queueItem.draggable = false;
                        
                        // Update current video playing text
                        const text = queueItem.textContent.trim();
                        const name = text.split(' - ')[0].trim();
                        document.getElementById('currentVideoPlaying').textContent = name;
                    }
                }
            }
        }

        function playNextVideo(index, videos) {
            console.log(`Playing next video: index=${index}`);
            if (index < videos.length) {
                setTurningPointState(true, videos[index].name);
                updateActiveVideo(index);
                
                // Start countdown for this video (28 seconds)
                const nextIndex = index + 1;
                if (nextIndex < videos.length) {
                    startCountdownTimer(28, () => playNextVideo(nextIndex, videos));
                } else {
                    // Last video - will play for 28 seconds in layer 2, then continue for 30 more seconds in group layers
                    startCountdownTimer(28, () => {
                        // After layer 2 turns off, show message that videos are finishing in groups
                        setTurningPointState(true, "Finishing in groups (30 seconds)");
                        
                        // Clear active video highlighting but keep the slot disabled
                        document.querySelectorAll('.slot').forEach(slot => {
                            slot.classList.remove('active-video');
                        });
                        
                        // Start the final 30 second countdown
                        startCountdownTimer(30, () => {
                            console.log('Final countdown complete - clearing all slots');
                            
                            // Get full data for all burners in slots before clearing them
                            const burnersToRemove = [];
                            document.querySelectorAll('.slot .queue-item').forEach(item => {
                                if (item.dataset.name) {
                                    // Extract all necessary identifying information
                                    const burnerData = {
                                        name: item.dataset.name,
                                        challenge_point: item.dataset.challenge_point,
                                        envi_state: item.dataset.envi_state
                                    };
                                    burnersToRemove.push(burnerData);
                                }
                            });
                            
                            console.log('Burners to remove from backend queue:', burnersToRemove);
                            
                            // Send a request to clear these specific burners from the backend queue
                            fetch('/clear-processed-burners', {
                                method: 'POST',
                                headers: {
                                    'Content-Type': 'application/json',
                                },
                                body: JSON.stringify({ burners_to_remove: burnersToRemove })
                            })
                            .then(response => {
                                if (!response.ok) {
                                    console.error('Failed to clear processed burners');
                                }
                                return response.json();
                            })
                            .then(data => {
                                console.log('Backend response:', data);
                            })
                            .catch(error => {
                                console.error('Error clearing processed burners:', error);
                            });
                            
                            setTurningPointState(false);
                            
                            // Simply clear all slots when done - with explicit logging
                            const slots = document.querySelectorAll('.slot');
                            console.log(`Clearing ${slots.length} slots`);
                            slots.forEach((slot, i) => {
                                console.log(`Clearing slot ${i}`);
                                slot.innerHTML = '';
                            });
                            
                            // Update play button state
                            updatePlayAllButton();
                            
                            // Show experience complete message
                            const status = document.getElementById('status');
                            status.style.display = 'block';
                            status.className = 'status success';
                            status.textContent = 'Turning Point Experience Complete!';
                            setTimeout(() => {
                                status.style.display = 'none';
                            }, 3000);
                        });
                    });
                }
            }
        }

        function playAllVideos() {
            const slots = document.querySelectorAll('.slot');
            const videos = Array.from(slots).map((slot, index) => {
                const item = slot.querySelector('.queue-item');
                if (!item) return null;
                
                try {
                const text = item.textContent.trim();
                    // Check if the text contains the expected delimiters
                    const parts = text.split(' - ');
                    const name = parts[0].trim();
                    
                    let challenge_point = '', envi_state = '';
                    if (parts.length > 1) {
                        const rest = parts[1];
                        const envParts = rest.split(' to ');
                        challenge_point = envParts[0].trim();
                        envi_state = envParts.length > 1 ? envParts[1].trim() : '';
                    }
                
                const videoData = {
                    index: index,
                        name: name,
                        challenge_point: challenge_point,
                        envi_state: envi_state,
                    video: item.dataset.video,
                        channel: parseInt(item.dataset.channel) // Note: +1 will be added on the backend
                };
                
                console.log('Video data:', videoData);  // Debug log
                return videoData;
                } catch (error) {
                    console.error('Error parsing video data:', error);
                    return null;
                }
            }).filter(v => v !== null);

            if (videos.length === 0) {
                const status = document.getElementById('status');
                status.style.display = 'block';
                status.className = 'status error';
                status.textContent = 'No videos selected';
                setTimeout(() => {
                    status.style.display = 'none';
                }, 3000);
                return;
            }

            const requestData = { videos: videos };
            console.log('Sending request data:', requestData);  // Debug log

            // Set turning point to running state
            setTurningPointState(true, "Intro Video");
            
            // Start intro countdown (67 seconds) and chain to first video when done
            startCountdownTimer(67, () => playNextVideo(0, videos));

            fetch('/play-all', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify(requestData)
            })
            .then(response => {
                if (!response.ok) {
                    return response.json().then(err => {
                        console.error('Server error:', err);  // Debug log
                        throw new Error(err.detail || 'Server error');
                    });
                }
                return response.json();
            })
            .then(data => {
                const status = document.getElementById('status');
                status.style.display = 'block';
                if (data.status === 'success') {
                    status.className = 'status success';
                    status.textContent = 'All videos triggered successfully!';
                } else {
                    status.className = 'status error';
                    status.textContent = 'Error: ' + data.message;
                    // If there was an error, set turning point back to idle
                    setTurningPointState(false);
                }
                setTimeout(() => {
                    status.style.display = 'none';
                }, 3000);
            })
            .catch(error => {
                console.error('Error:', error);  // Debug log
                const status = document.getElementById('status');
                status.style.display = 'block';
                status.className = 'status error';
                status.textContent = 'Error: ' + error.message;
                // If there was an error, set turning point back to idle
                setTurningPointState(false);
                setTimeout(() => {
                    status.style.display = 'none';
                }, 3000);
            });
        }

        function stopAllVideos() {
            console.log('Stopping all videos and clearing burners');

            // Show confirmation dialog
            if (!confirm('Are you sure you want to STOP Turning Point and CLEAR ALL BURNERS?')) {
                return;
            }

            // Get full data for all burners in slots before clearing them
            const burnersToRemove = [];
            document.querySelectorAll('.slot .queue-item').forEach(item => {
                if (item.dataset.name) {
                    // Extract all necessary identifying information
                    const burnerData = {
                        name: item.dataset.name,
                        challenge_point: item.dataset.challenge_point,
                        envi_state: item.dataset.envi_state
                    };
                    burnersToRemove.push(burnerData);
                }
            });
            
            console.log('Burners to remove from backend queue:', burnersToRemove);

            fetch('/stop-all', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({ burners_to_remove: burnersToRemove })
            })
            .then(response => {
                if (!response.ok) {
                    return response.json().then(err => {
                        console.error('Server error:', err);
                        throw new Error(err.detail || 'Server error');
                    });
                }
                return response.json();
            })
            .then(data => {
                const status = document.getElementById('status');
                status.style.display = 'block';
                if (data.status === 'success') {
                    status.className = 'status success';
                    status.textContent = 'All videos stopped!';
                    
                    // Reset UI state
                    setTurningPointState(false);
                    
                    // Clear any active video highlights
                    updateActiveVideo(-1);
                    
                    // Clear timer
                    if (window.countdownInterval) {
                        clearInterval(window.countdownInterval);
                        window.countdownInterval = null;
                    }
                    
                    // Simply clear all slots
                    document.querySelectorAll('.slot').forEach(slot => {
                        slot.innerHTML = '';
                    });
                    
                    // Update play button state
                    updatePlayAllButton();
                    
                } else {
                    status.className = 'status error';
                    status.textContent = 'Error: ' + data.message;
                }
                setTimeout(() => {
                    status.style.display = 'none';
                }, 3000);
            })
            .catch(error => {
                console.error('Error:', error);
                const status = document.getElementById('status');
                status.style.display = 'block';
                status.className = 'status error';
                status.textContent = 'Error: ' + error.message;
                setTimeout(() => {
                    status.style.display = 'none';
                }, 3000);
            });
        }

        function restartTurningPoint() {
            console.log('Stopping Turning Point but keeping burners');

            // Show confirmation dialog - note that this preserves slots
            if (!confirm('Are you sure you want to STOP Turning Point but KEEP ALL BURNERS?')) {
                return;
            }

            fetch('/restart', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                }
            })
            .then(response => {
                if (!response.ok) {
                    return response.json().then(err => {
                        console.error('Server error:', err);
                        throw new Error(err.detail || 'Server error');
                    });
                }
                return response.json();
            })
            .then(data => {
                const status = document.getElementById('status');
                status.style.display = 'block';
                if (data.status === 'success') {
                    status.className = 'status success';
                    status.textContent = 'Turning Point stopped (burners preserved)';
                    
                    // Reset UI state but don't clear slots
                    setTurningPointState(false);
                    
                    // Clear any active video highlights
                    updateActiveVideo(-1);
                    
                    // Clear timer
                    if (window.countdownInterval) {
                        clearInterval(window.countdownInterval);
                        window.countdownInterval = null;
                    }
                    
                    // Enable all slots (they may have been disabled during playback)
                    document.querySelectorAll('.slot').forEach(slot => {
                        slot.classList.remove('disabled');
                        
                        // Re-enable dragging for any items
                        const item = slot.querySelector('.queue-item');
                        if (item) {
                            item.classList.remove('disabled');
                            item.draggable = true;
                        }
                    });
                    
                    // Update play button state
                    updatePlayAllButton();
                    
                } else {
                    status.className = 'status error';
                    status.textContent = 'Error: ' + data.message;
                }
                setTimeout(() => {
                    status.style.display = 'none';
                }, 3000);
            })
            .catch(error => {
                console.error('Error:', error);
                const status = document.getElementById('status');
                status.style.display = 'block';
                status.className = 'status error';
                status.textContent = 'Error: ' + error.message;
                setTimeout(() => {
                    status.style.display = 'none';
                }, 3000);
            });
        }

        function fillSlotsFromQueue() {
            console.log('Filling slots from queue');
            
            // Get all queue items
            const queueItems = document.querySelectorAll('#queue-list .queue-item');
            if (queueItems.length === 0) {
                // Show message if queue is empty
                const status = document.getElementById('status');
                status.style.display = 'block';
                status.className = 'status error';
                status.textContent = 'Queue is empty!';
                setTimeout(() => {
                    status.style.display = 'none';
                }, 3000);
                return;
            }
            
            // Get all slots
            const emptySlots = Array.from(document.querySelectorAll('.slot')).filter(slot => 
                slot.children.length === 0 && !slot.classList.contains('disabled')
            );
            
            if (emptySlots.length === 0) {
                // All slots already filled
                const status = document.getElementById('status');
                status.style.display = 'block';
                status.className = 'status error';
                status.textContent = 'All slots are already filled!';
                setTimeout(() => {
                    status.style.display = 'none';
                }, 3000);
                return;
            }
            
            // Determine how many to move (min of queue size and empty slots)
            const itemsToMove = Math.min(queueItems.length, emptySlots.length);
            
            // Move items from queue to empty slots
            for (let i = 0; i < itemsToMove; i++) {
                const item = queueItems[i];
                const slot = emptySlots[i];
                
                // Clone the item
                const clone = item.cloneNode(true);
                clone.style.opacity = '0';
                
                // Copy the drag event handler
                clone.ondragstart = (e) => {
                    if (clone.classList.contains('disabled')) {
                        e.preventDefault();
                        return;
                    }
                    e.dataTransfer.setData('text/plain', clone.id);
                };
                
                // Add to slot
                slot.appendChild(clone);
                
                // Remove from queue
                item.parentNode.removeChild(item);
                
                // Fade in effect
                setTimeout(() => {
                    clone.style.transition = 'opacity 0.5s';
                    clone.style.opacity = '1';
                }, 10);
            }
            
            // Show status message
            const status = document.getElementById('status');
            status.style.display = 'block';
            status.className = 'status success';
            status.textContent = `Moved ${itemsToMove} burners to slots!`;
            setTimeout(() => {
                status.style.display = 'none';
            }, 3000);
            
            // Update play button state
            updatePlayAllButton();
        }

        // Initialize help status
        fetchHelpStatus();
        
        // Update queue and help status every 5 seconds
        setInterval(() => {
            updateQueue();
            fetchHelpStatus();
        }, 5000);
        
        // Initial update
        updateQueue();

        // Initialize discard bucket
        const discardBucket = document.getElementById('discard-bucket');
        discardBucket.ondragover = (e) => {
            e.preventDefault();
            discardBucket.classList.add('dragover');
        };
        discardBucket.ondragleave = () => {
            discardBucket.classList.remove('dragover');
        };
        discardBucket.ondrop = (e) => {
            e.preventDefault();
            discardBucket.classList.remove('dragover');
            
            const itemId = e.dataTransfer.getData('text/plain');
            const item = document.getElementById(itemId);
            
            if (item) {
                // Show confirmation
                if (confirm("Are you sure you want to remove this burner?")) {
                    // Get the name for status message
                    const name = item.textContent.trim().split(' - ')[0].trim();
                    
                    // Get full burner data to remove from backend
                    if (item.dataset.name && item.dataset.challenge_point && item.dataset.envi_state) {
                        // Create burner data object matching the format expected by the backend
                        const burnerData = {
                            name: item.dataset.name,
                            challenge_point: item.dataset.challenge_point,
                            envi_state: item.dataset.envi_state
                        };
                        
                        // Remove this specific burner from the backend queue
                        fetch('/clear-processed-burners', {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json',
                            },
                            body: JSON.stringify({ 
                                burners_to_remove: [burnerData] 
                            })
                        })
                        .then(response => {
                            if (!response.ok) {
                                console.error('Failed to remove burner from backend queue');
                            }
                            return response.json();
                        })
                        .then(data => {
                            console.log('Backend response:', data);
                        })
                        .catch(error => {
                            console.error('Error removing burner from backend queue:', error);
                        });
                    }
                    
                    // Remove from DOM with fade-out effect
                    item.style.transition = "opacity 0.5s";
                    item.style.opacity = 0;
                    setTimeout(() => {
                        item.parentNode.removeChild(item);
                        
                        // Show status message
                        const status = document.getElementById('status');
                        status.style.display = 'block';
                        status.className = 'status success';
                        status.textContent = `Removed burner: ${name}`;
                        setTimeout(() => {
                            status.style.display = 'none';
                        }, 3000);
                        
                        // Update play button state
                        updatePlayAllButton();
                    }, 500);
                }
            }
        };

        // Function to remove specific burners from backend queue
        function removeFromBackendQueue(burnerNames) {
            console.log(`Removing ${burnerNames.length} burners from backend queue:`, burnerNames);
            
            fetch('/remove-from-queue', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                    names: burnerNames
                })
            })
            .then(response => {
                if (!response.ok) {
                    console.error('Failed to remove burners from backend queue');
                    return;
                }
                console.log('Successfully removed burners from backend queue');
            })
            .catch(error => {
                console.error('Error removing burners from backend queue:', error);
            });
        }
    </script>
</body>
</html> 